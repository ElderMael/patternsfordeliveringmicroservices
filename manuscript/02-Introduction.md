# Introduction

The microservices architecture pattern has changed the way we create
software at many levels. I remember working on my first microservice
project during the times before Kubernetes and in the apogee of the
Netflix platform implementation.

While I had worked most of my career with JVM related technologies, at
the time I worked as a front-end developer but on the sidelines I
helped a friend to deliver a project using the first versions of Spring
Boot and Netflix integrations.

From that point of time to the moment of writing these lines I have
been in various other projects implementing a similar architecture
style but different implementing technologies and also working on
different positions.

While I can say that I matured as a developer during the monolith era
of the early 2000's, I think my most challenging projects were the
ones in which I was not coding application code but platform code. This
means that I coded small libraries and utilities for developers in
order to accelerate adoption of platforms such as Kubernetes.

While working on Kubernetes related technologies for more than two
years I started to realize that developers required opinionated tools
but with enough flexibility to allow them to skip stages and do their
jobs.

This is when I started my research on tools and patterns that I have
used over the years to allow adoption of the microservices paradigm
and at the same time, give developers enough tools to work confidently
on their own services without cluttering their job with platform code.
